from __future__ import print_functionfrom __future__ import absolute_importfrom builtins import Exceptionfrom subprocess import Popen, check_outputimport os, sys, re, getopt, getpass, time,  configparser, json, logging, glob, signal, shlex, platform#imports for scp which used Paramico as transportimport scpimport paramikofrom scp import SCPClientfrom fabric2 import Connection#imports local for projectfrom test_bl.test_sonata_plugin.configs_sonata import sonata_suite_configfrom test_bl.test_bl_tools import var_utilsclass ExtScripts:    def __init__(self,                 config_file        = None,                 commands_file      = None,                 script_location    = None,                 script_type="win"                ):        """        :param commands_file:        :param script_location:        :param script_type:        """        '''CONFIG ASSUMING ENV VARS'''        self.commands_file=commands_file        self.script_location=script_location        self.script_type = script_type        '''        CONFIG FILE USED BY THE CURRENT TEST SUITE        '''        self.conf = config_file        '''        SETUP SSH        '''        self.ssh_target_ip      = None        self.ssh_target_port    = None        self.ssh_target_user    = None        self.ssh_target_pswd    = None        self.ssh_client         = None        '''        SETUP SSH COPY        '''        self.ssh_scp_content_location   = None        self.ssh_target_dir             = None        '''        SETUP FABRIC CONNECTION        '''        self.fabric_connection = None        '''        SETUP commands to be executed remotely        '''        self.ssh_commands_to_exec = {}        '''SETUP a possibility to check commands execution of the remote host        via dedicated script.         The script command should be part of the above        dictionary and key for that should be made known in advance        '''        self.ssh_ded_test_key = None        '''SETUP PARAMS when CONFIG is available'''        if self.conf == None:            '''SETUP VIRT_BOX exec commands (VBoxmanage based) from conf file PREFS'''            self.vm_start_cmnd      = None            self.vm_shutdown_cmnd   = None            self.vm_resnap_cmnd     = None            self.vm_makesnap_cmnd   = None            '''SETUP REMOTE COMMANDS TO BE EXECUTED ON SUT START/STOP and OTHER ???? not envisioned yet. To be repeated in set_remote_commands function'''            self.sut_start_commands = None            self.sut_stop_commands  = None            '''SETUP Logging'''            self.logger             = None        else:            '''SETUP VIRT_BOX exec commands (VBoxmanage based) from conf file PREFS'''            self.set_vbox_manage()            '''SETUP REMOTE COMMANDS TO BE EXECUTED ON SUT START/STOP'''            self.set_remote_commands()            '''SETUP Logging'''            if self.conf.logging_tools != None:                self.logger = self.conf.logging_tools.get_logger(__name__)            '''SETUP SSH Connection PARAMS'''            self.set_connection_params()            '''SETUP location of the LOGGING server external to BL'''            self.vm_log_srv_exec = self.conf.vm_log_srv_exec            self.vm_log_srv_exec_dir = self.conf.vm_log_srv_dir        '''SETUP Logger banner helpers'''        self.vm_start_ssh_test_banner = var_utils.Varutils().build_VM_ssh_test_banner        self.vm_ssh_cmds_exec_banner = var_utils.Varutils().remote_commands_exec_banner        return    '''------------------------------------------------------------------------------------------------------------------'''    '''Functions for remote shell scripts execution'''    def start_sut(self):        self.set_fabric_connection()        self.fabric_run_commands()        time.sleep(40)        return    def stop_sut(self):        self.set_fabric_connection()        self.fabric_run_commands()        return    def restart_sut(self):        self.start_sut()        self.stop_sut()        return    '''------------------------------------------------------------------------------------------------------------------'''    '''Functions VM execution'''    def vm_start(self):        self.logger.debug("<== Start  VM ==>")        self.logger.debug(self.vm_start_cmnd)        if self.conf.syst == 'Windows':            p = Popen(self.vm_start_cmnd,                      shell=False,                      cwd=self.script_location                      )            stdout, stderr = p.communicate()        elif self.conf.syst == 'Linux':            # p = Popen(self.vm_shutdown_cmnd,            p = Popen(shlex.split(self.vm_start_cmnd),                      shell=False,                      cwd=self.script_location                      )            stdout, stderr = p.communicate()        test = 1        while test == 1:            try:                time.sleep(30)                self.vm_start_ssh_test_banner(server_ip = self.ssh_target_ip,                                            server_port = self.ssh_target_port,                                            ending='attempts to connect to VM',                                            logging_level='DEBUG',                                            logger=self.logger                                            )                self.create_Paramiko_SSHClient()                ssh_trans=self.ssh_client.get_transport()                ssh_conn_state = ssh_trans.is_active()                if ssh_conn_state == True:                    test = 2                else:                    raise Exception('Something UnPredictable is happening with SSH_Client')                self.vm_start_ssh_test_banner(server_ip=self.ssh_target_ip,                                              server_port=self.ssh_target_port,                                              ending='has connected to VM',                                              logging_level='DEBUG',                                              logger=self.logger                                              )            except:                try:                    raise                except TimeoutError:                    self.ssh_client.close()                    continue                except Exception as e:                    self.ssh_client.close()                    continue        p.terminate()        p.kill()        return    def vm_shutdown(self):        self.logger.debug("<==SHUTTING DOWN NEEDED image IF IT IS UP ==>")        self.logger.debug(self.vm_shutdown_cmnd)        if self.conf.syst == 'Windows':            p = Popen(self.vm_shutdown_cmnd,                      # p = Popen(shlex.split(self.vm_shutdown_cmnd),                      shell=False,                      cwd=self.script_location                      )            stdout, stderr = p.communicate()            p.terminate()            p.kill()            self.logger.debug("<==SHUTTING DOWN NEEDED image -|DONE|- ==>")            return        elif self.conf.syst == 'Linux':            # p = Popen(self.vm_shutdown_cmnd,            p = Popen(shlex.split(self.vm_shutdown_cmnd),                      shell=False,                      cwd=self.script_location                      )            stdout, stderr = p.communicate()            p.terminate()            p.kill()            self.logger.debug("<==SHUTTING DOWN NEEDED image -|DONE|- ==>")            return    def vm_restore_snap(self):        if self.conf.syst == 'Windows':            p = Popen(self.vm_resnap_cmnd,                      shell=False,                      cwd=self.script_location                      )            stdout, stderr = p.communicate()            p.terminate()            p.kill()            return        elif self.conf.syst == 'Linux':                p = Popen(shlex.split(self.vm_resnap_cmnd),                          shell=False,                          cwd=self.script_location                          )                stdout, stderr = p.communicate()                p.terminate()                p.kill()                return    '''------------------------------------------------------------------------------------------------------------------'''    '''Functions for LOGGING server control'''    def start_log_server(self):        p = Popen(self.vm_log_srv_exec,                  shell=False,                  cwd=self.vm_log_srv_exec_dir                  )        stdout, stderr = p.communicate()        p.terminate()        p.kill()        return    def stop_logserver(self):        self.syst = platform.system()        if self.syst == 'Windows':            name = "javaw"            log_srv_pid = check_output(["ps", "-laW"],                                       universal_newlines=True)            # os.kill(get_pid(whatever_you_search), signal.SIGTERM)  # or signal.SIGKILL            # os.kill(check_output(["pidof", name]),            #       signal.SIGTERM)  # or signal.SIGKILL            proc_names_data = log_srv_pid.split('\n')            pid = []            pid = self.getPidByName(proc_name=name,                                    proc_data_in=proc_names_data)        elif self.syst == 'Linux':            name = "apache-chainsaw-2.0.0"            log_srv_pid = check_output(["ps", "-afx"],                                    universal_newlines=True)            # os.kill(get_pid(whatever_you_search), signal.SIGTERM)  # or signal.SIGKILL            # os.kill(check_output(["pidof", name]),            #       signal.SIGTERM)  # or signal.SIGKILL            proc_names_data = log_srv_pid.split('\n')            pid = []            pid = self.getPidByName(proc_name=name,                                    proc_data_in = proc_names_data)        for i in pid:            os.kill(i,                    signal.SIGTERM)  # or signal.SIGKILL        return    '''------------------------------------------------------------------------------------------------------------------'''    '''Common tools'''    '''------------------------------------------------------------------------------------------------------------------'''    '''=============================================================================================================='''    '''For linux only'''    '''=============================================================================================================='''    def getPidByName(self,                     proc_name = None,                     proc_data_in = None):        if proc_data_in != None:            process = proc_data_in        else:            process = check_output(["ps", "-afx"]).split('\n')        pid =[]        for x in range(0, len(process)):            entry_cnt = 0            args_prep =  re.sub("\s+", ",", process[x].strip())            args = args_prep.split(',')            for j in range(0, len(args)):                part = args[j]                if (proc_name in part):                    if entry_cnt == 0:                        pid.append(int(args[0]))                        entry_cnt = entry_cnt + 1                    else:                        continue        return pid    def get_pid_from_proc(self):        for dirname in os.listdir('/proc'):            if dirname == 'curproc':                continue            try:                with open('/proc/{}/cmdline'.format(dirname), mode='rb') as fd:                    content = fd.read().decode().split('\x00')            except Exception:                continue            for i in sys.argv[1:]:                if i in content[0]:                    print('{0:<12} : {1}'.format(dirname, ' '.join(content)))        return    ''' Function to execute      '''    def load_env_vars(self):        #def set_env_vars(self):        """           Run the cmd file to set env variables           :param default_level:           :param env_key:           :return:        """        ''' Run the cmd file to set env variables'''        if self.script_type == "win":            p = Popen(self.commands_file,                      shell=False,                      cwd=self.script_location                      )            stdout, stderr = p.communicate()            p.terminate()            p.kill()            return        if self.script_type == "sh":            return    def scp_files(self):        '''        ssh = SSHClient()        ssh.load_system_host_keys()        ssh.connect('10.11.10.11')        with SCPClient(ssh.get_transport()) as scp:            scp.put('test.txt', 'test2.txt')            scp.get('test2.txt')        '''        #ssh = self.create_Paramiko_SSHClient(server, port, user, password)        #ssh = self.create_Paramiko_SSHClient('10.11.10.11', 22, 'root', 'root')        '''SET CONFIG SCP PARAMS'''        if self.conf != None:            '''SET CONNECTION PREFS'''            self.set_connection_params()            '''SET SSH CLIENT AND TRANSPORT'''            self.create_Paramiko_SSHClient()            scp = SCPClient(self.ssh_client.get_transport())            '''SET PREFS AND COPY ALL CONFIGS AND SCRIPTS to DUT'''            self.set_scp_details()            scp.put(self.ssh_scp_content_location, remote_path=self.ssh_target_dir)            return        else:            raise ValueError("Configuration file is not PRESENT in the class")    '''------------------------------------------------------------------------------------------------------------------'''    '''Functions for SCP and remote commands exec over SSH'''    '''------------------------------------------------------------------------------------------------------------------'''    def set_connection_params(self):        '''         SET CONNECTION PREFS         '''        if self.conf != None:            self.ssh_target_ip      = self.conf.ssh_host            self.ssh_target_port    = self.conf.ssh_port            self.ssh_target_user    = self.conf.ssh_user            self.ssh_target_pswd    = self.conf.ssh_pwd        else:            raise Exception('Configuration class is NOT loaded BUT needed. To early to set that!')        return    '''------------------------------------------------------------------------------------------------------------------'''    '''SETTERS for VARIOUS PARAMS'''    '''------------------------------------------------------------------------------------------------------------------'''    def create_Paramiko_SSHClient(self):        '''        Setup pure paramico SSH client        :return:        '''        if self.conf == None:            self.set_connection_params()        if self.ssh_client != None:            self.ssh_client.close()        self.ssh_client = paramiko.SSHClient()        self.ssh_client.load_system_host_keys()        self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())        self.logger.debug(" <== CONNECTION PARAMS: " + self.ssh_target_ip + ": " + self.ssh_target_port + " ==>")        self.ssh_client.connect(hostname    =self.ssh_target_ip,                               port         =self.ssh_target_port,                               username     =self.ssh_target_user,                               password     =self.ssh_target_pswd                               )        return    def set_fabric_connection(self):        '''        SET CONNECTION PREFS        '''        self.set_connection_params()        self.fabric_connection = Connection(#host="kd",                                            host = self.ssh_target_ip,                                            port=self.ssh_target_port,                                            user=self.ssh_target_user)        self.fabric_connection.connect_kwargs.password = self.ssh_target_pswd        return    def set_scp_details(self):        '''        SET ALL THE PARAMS RELATED TO COPING        :return:        '''        self.ssh_scp_content_location= self.conf.ssh_content_to_copy        self.ssh_target_dir = self.conf.ssh_target_dir        return    def set_vbox_manage(self):        """SETUP VIRT_BOX exec commands (VBoxmanage based) from conf file PREFS"""        if self.conf != None:            self.vm_start_cmnd = self.conf.vm_vbox_manage + ' startvm ' + self.conf.vm_alt_img + ' --type headless'            self.vm_shutdown_cmnd = self.conf.vm_vbox_manage + ' controlvm ' + self.conf.vm_alt_img + ' poweroff'            self.vm_resnap_cmnd = self.conf.vm_vbox_manage + ' snapshot ' + self.conf.vm_alt_img + ' restore ' + self.conf.vm_alt_img_snapshot            self.vm_makeclone_cmnd = self.conf.vm_vbox_manage + ' clonevm ' + self.conf.vm_alt_img        else:            raise Exception("Test Suite`s conf file is not Present")        return    def set_remote_commands(self):        """SETUP REMOTE/SSH exec commands (VBoxmanage based) from conf file PREFS"""        if self.conf != None:            self.sut_start_commands = self.conf.ssh_remote_commands_conf_start            self.sut_stop_commands = self.conf.ssh_remote_commands_conf_stop        else:            raise Exception("Test Suite`s conf file is not Present")        return    '''------------------------------------------------------------------------------------------------------------------'''    '''UTILITY FUNCTIONS '''    '''------------------------------------------------------------------------------------------------------------------'''    def fabric_run_commands(self):        ''' Lets create a possibility of            dedicated test on remote host with a ASH script            which may be needed only in some            cases. The script should be uploaded to the target machine            in the same archive as config files and start scripts.            For that configure special key on the class level and            after check whether it exists pop a command for the script execution            from common dict (may not be entirely good idea but will work)        '''        ded_test_command= None        if self.ssh_ded_test_key != None:            ded_test_command = self.ssh_commands_to_exec.pop(self.ssh_ded_test_key)            self.vm_ssh_cmds_exec_banner(command    = ded_test_command,                                         ending     = ' for testing exec results content',                                         logging_level  = 'DEBUG',                                         logger         = self.logger                                         )        else:            return        for key,command in self.ssh_commands_to_exec.items():            if key == self.ssh_ded_test_key:                ded_test_command = self.ssh_commands_to_exec.pop(self.ssh_ded_test_key)                continue            else:                result = self.fabric_connection.run(command)            if ded_test_command != None:                    result_dedicated_test = self.fabric_connection.run(ded_test_command)            else:                    result_dedicated_test = None            self.vm_ssh_cmds_exec_banner(command=command,                                         ending=' for the key ' + str(key) + ' has been executed ',                                         exec_res01='result.ok: ' + str(result.ok),                                         exec_res02='result.return_code: ' + str(result.return_code),                                         exec_res03='result_dedicated_test.return_code: ' + str(                                             result_dedicated_test.return_code),                                         logging_level='DEBUG',                                         logger=self.logger                                         )            if result.ok==True and result.return_code == 0 and (result_dedicated_test != None or result_dedicated_test.return_code == 0):                    pass            else:                    raise Exception('Last command did not go thru. Execution interrupted')        return    def set_test_env(self):        """        Function:         1) starts VM         2) copies current archive of configs and scripts to SUT Host         3) sets predefined start SUT remote commands as default         4) executes then in start)sut function        :return:        """        '''make it avalable to the ScriptsControlling class'''        # es.conf = sonata_conf        self.vm_shutdown()        self.vm_start()        '''test whether files can be copied via scp'''        self.scp_files()        '''Do the test for actions on the remote host'''        self.ssh_ded_test_key = 'test_exec'        '''        commands_to_exec = {}        commands_to_exec['com00'] = 'cd /usr/bin/dolphin'        commands_to_exec['com01'] = '/bin/tar -xzvf /usr/bin/dolphin/bl_tests.tar.gz'        commands_to_exec['com02'] = 'cd /usr/bin/dolphin/bl_tests'        commands_to_exec['com03'] = './StartSonataOnly.bash'        commands_to_exec['com04'] = 'cd /usr/bin/dolphin'        commands_to_exec['com05'] = 'rm -f ./build_num.txt'        commands_to_exec[self.ssh_ded_test_key] = './testScr_param.bash TESTING_LAST_COMMAND_SUCCESS_ON_SETUP'                self.ssh_commands_to_exec = commands_to_exec        '''        '''Start the SUT on the remote box'''        self.ssh_commands_to_exec = self.sut_start_commands        self.start_sut()        return    def tear_down_test_env(self):        """        Function:         1) Stops SUT         2) Stops VM         3) Restores clean snap        :return:        """        self.ssh_commands_to_exec.clear()        '''        commands_to_exec = {}        commands_to_exec['com01'] = 'cd /usr/bin/dolphin/bl_tests'        commands_to_exec['com03'] = './StopSonataOnly.bash'        commands_to_exec[self.ssh_ded_test_key] = './testScr_param.bash TESTING_LAST_COMMAND_SUCCESS_ON_TEARINGDOWN'                        self.ssh_commands_to_exec = commands_to_exec        '''        self.ssh_commands_to_exec = self.sut_stop_commands        self.stop_sut()        self.vm_shutdown()        self.vm_restore_snap()        returndef test_this():    import os, sys, re, getopt, getpass, time, logging    from builtins import Exception    from subprocess import Popen    # imports for scp which used Paramico as transport    import scp    import paramiko    from scp import SCPClient    from fabric2 import Connection    # imports local for project    from test_bl.test_sonata_plugin.configs_sonata import sonata_suite_config    from test_bl.test_bl_tools import var_utils    '''Instance of config. All preferences come from it. Connection and script commands'''    sonata_conf = sonata_suite_config.SonataSuiteConfig()    '''Do the test for actions on the remote host'''    '''Instance External Scripting class'''    es = ExtScripts(sonata_conf)    '''Start log server before everything else'''    es.start_log_server()    es.stop_logserver()    #es.ssh_ded_test_key = 'test_exec'    #es.set_test_env()    #es.tear_down_test_env()    '''make it avalable to the ScriptsControlling class'''    #es.conf = sonata_conf    #es.vm_shutdown()    #es.vm_start()    '''test whether files can be copied via scp'''    #es.scp_files()    '''    commands_to_exec = {}    commands_to_exec['com00']               = 'cd /usr/bin/dolphin'    commands_to_exec['com01']               = '/bin/tar -xzvf /usr/bin/dolphin/bl_tests.tar.gz'    commands_to_exec['com02']               = 'cd /usr/bin/dolphin/bl_tests'    commands_to_exec['com03']               = './StartSonataOnly.bash'    commands_to_exec['com04']               = 'cd /usr/bin/dolphin'    commands_to_exec['com05']               = 'rm -f ./build_num.txt'    commands_to_exec[es.ssh_ded_test_key]   = './testScr_param.bash TESTING_LAST_COMMAND_SUCCESS_ON_SETUP'    es.ssh_commands_to_exec = commands_to_exec    '''    '''TODO: Think of controlling execution.             dedicated key name for the script              that tests other scripts correctness.                 '''    '''test loading configuration params as env vars'''    # es.load_env_vars()    '''Test commands can        execution on the remote host    '''    #es.stop_sut()    #es.start_sut()    #es.start_sut()    '''    es.ssh_commands_to_exec.clear()    commands_to_exec['com01'] = 'cd /usr/bin/dolphin/bl_tests'    commands_to_exec['com03'] = './StopSonataOnly.bash'    commands_to_exec[es.ssh_ded_test_key] = './testScr_param.bash TESTING_LAST_COMMAND_SUCCESS_ON_TEARINGDOWN'    es.ssh_commands_to_exec = commands_to_exec    '''    #es.stop_sut()    #es.restart_sut()    #es.vm_shutdown()    #es.vm_restore_snap()    '''Test ENV Var Setup'''    #es.commands_file = 'C:\\data\\kronshtadt\\QA\\BL\\AutomationFrameworkDesign\\bl_frame_work\\env_setup.cmd'    returnif __name__ == "__main__":    test_this()